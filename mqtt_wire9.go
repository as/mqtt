// MACHINE GENERATED BY 'go generate' COMMAND
// TO EDIT A TYPE OR METHOD, COPY IT TO ANOTHER FILE IN THE PACKAGE
package mqtt

import (
	"encoding/binary"
	"bytes"
	"io"
	"fmt"
	"github.com/as/wire9/varint"
)

func writestring(w io.Writer, s string, must int) (err error) {
	data := []byte(s)
	switch l := len(data); {
	case l > must:
		_, err = w.Write(data[:must])
	case l < must:
		_, err = w.Write(data[:l])
		if err != nil {
			return err
		}
		underflow := must - l
		_, err = w.Write(bytes.Repeat([]byte{0x00}, underflow))
	default:
		_, err = w.Write(data[:l])
	}
	return err
}

func ioErr(name, kind string, ac, ex int) error {
	return fmt.Errorf("%s: short %s: %d/%d", name, kind, ac, ex)
}

type String struct {
	N	uint16
	Data	[]byte
}

type Head struct {
	Flags	byte
	Len	varint.V
}

type PackConnPayload struct {
	Client	String
	Topic	String
	Message	String
	User	String
	Pass	String
}

type PackConnHead struct {
	Name		String
	Level		byte
	Flags		byte
	KeepAlive	uint16
}

type PackConn struct {
	Head	PackConnHead
	Payload	PackConnPayload
}

type PackConnAck struct {
	Flags	byte
	Return	byte
}

func (z *String) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.BigEndian, &z.N); err != nil {
		return err
	}

	z.Data = make([]byte, int(z.N))

	if n, err := r.Read(z.Data); err != nil || n != int(z.N) {
		return err
	}

	return nil
}

func (z *String) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.BigEndian, z.N); err != nil {
		return err
	}

	{
		x := int(z.N)
		if n, err := w.Write(z.Data[:x]); err != nil || n != x {
			return err
		}
	}
	return nil
}

func (z *Head) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.BigEndian, &z.Flags); err != nil {
		return err
	}

	if err := z.Len.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *Head) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.BigEndian, z.Flags); err != nil {
		return err
	}

	if err := z.Len.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *PackConnPayload) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Client.ReadBinary(r); err != nil {
		return err
	}

	if err := z.Topic.ReadBinary(r); err != nil {
		return err
	}

	if err := z.Message.ReadBinary(r); err != nil {
		return err
	}

	if err := z.User.ReadBinary(r); err != nil {
		return err
	}

	if err := z.Pass.ReadBinary(r); err != nil {
		return err
	}

	return nil
}

func (z *PackConnPayload) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Client.WriteBinary(w); err != nil {
		return err
	}

	if err := z.Topic.WriteBinary(w); err != nil {
		return err
	}

	if err := z.Message.WriteBinary(w); err != nil {
		return err
	}

	if err := z.User.WriteBinary(w); err != nil {
		return err
	}

	if err := z.Pass.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *PackConnHead) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := z.Name.ReadBinary(r); err != nil {
		return err
	}

	if err := binary.Read(r, binary.BigEndian, &z.Level); err != nil {
		return err
	}

	if err := binary.Read(r, binary.BigEndian, &z.Flags); err != nil {
		return err
	}

	if err := binary.Read(r, binary.BigEndian, &z.KeepAlive); err != nil {
		return err
	}

	return nil
}

func (z *PackConnHead) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Name.WriteBinary(w); err != nil {
		return err
	}

	if err := binary.Write(w, binary.BigEndian, z.Level); err != nil {
		return err
	}

	if err := binary.Write(w, binary.BigEndian, z.Flags); err != nil {
		return err
	}

	if err := binary.Write(w, binary.BigEndian, z.KeepAlive); err != nil {
		return err
	}

	return nil
}

func (z *PackConn) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := z.Head.WriteBinary(w); err != nil {
		return err
	}

	if err := z.Payload.WriteBinary(w); err != nil {
		return err
	}

	return nil
}

func (z *PackConnAck) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.BigEndian, &z.Flags); err != nil {
		return err
	}

	if err := binary.Read(r, binary.BigEndian, &z.Return); err != nil {
		return err
	}

	return nil
}

func (z *PackConnAck) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.BigEndian, z.Flags); err != nil {
		return err
	}

	if err := binary.Write(w, binary.BigEndian, z.Return); err != nil {
		return err
	}

	return nil
}
